const C=new WeakMap;function $(s,t,e,i){if(!s&&!C.has(t))return!1;const n=C.get(t)??new WeakMap;C.set(t,n);const o=n.get(e)??new Set;n.set(e,o);const a=o.has(i);return s?o.add(i):o.delete(i),a&&s}function I(s,t){let e=s.target;if(e instanceof Text&&(e=e.parentElement),e instanceof Element&&s.currentTarget instanceof Element){const i=e.closest(t);if(i&&s.currentTarget.contains(i))return i}}function V(s,t,e,i={}){const{signal:n,base:o=document}=i;if(n?.aborted)return;const{once:a,...r}=i,l=o instanceof Document?o.documentElement:o,u=!!(typeof i=="object"?i.capture:i),p=m=>{const g=I(m,s);if(g){const w=Object.assign(m,{delegateTarget:g});e.call(l,w),a&&(l.removeEventListener(t,p,r),$(!1,l,e,h))}},h=JSON.stringify({selector:s,type:t,capture:u});$(!0,l,e,h)||l.addEventListener(t,p,r),n?.addEventListener("abort",()=>{$(!1,l,e,h)})}function c(){return c=Object.assign?Object.assign.bind():function(s){for(var t=1;t<arguments.length;t++){var e=arguments[t];for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&(s[i]=e[i])}return s},c.apply(this,arguments)}const T=(s,t)=>String(s).toLowerCase().replace(/[\s/_.]+/g,"-").replace(/[^\w-]+/g,"").replace(/--+/g,"-").replace(/^-+|-+$/g,"")||t||"",v=({hash:s}={})=>location.pathname+location.search+(s?location.hash:""),W=(s,t={})=>{const e=c({url:s=s||v({hash:!0}),random:Math.random(),source:"swup"},t);history.pushState(e,"",s)},P=(s=null,t={})=>{s=s||v({hash:!0});const e=c({},history.state,{url:s,random:Math.random(),source:"swup"},t);history.replaceState(e,"",s)},_=(s,t,e,i)=>{const n=new AbortController;return i=c({},i,{signal:n.signal}),V(s,t,e,i),{destroy:()=>n.abort()}};class f extends URL{constructor(t,e=document.baseURI){super(t.toString(),e)}get url(){return this.pathname+this.search}static fromElement(t){const e=t.getAttribute("href")||t.getAttribute("xlink:href")||"";return new f(e)}static fromUrl(t){return new f(t)}}class j{constructor(t){this.swup=void 0,this.pages=new Map,this.swup=t}get size(){return this.pages.size}get all(){const t=new Map;return this.pages.forEach((e,i)=>{t.set(i,c({},e))}),t}has(t){return this.pages.has(this.resolve(t))}get(t){const e=this.pages.get(this.resolve(t));return e&&c({},e)}set(t,e){e=c({},e,{url:t=this.resolve(t)}),this.pages.set(t,e),this.swup.hooks.callSync("cache:set",{page:e})}update(t,e){t=this.resolve(t);const i=c({},this.get(t),e,{url:t});this.pages.set(t,i)}delete(t){this.pages.delete(this.resolve(t))}clear(){this.pages.clear(),this.swup.hooks.callSync("cache:clear")}prune(t){this.pages.forEach((e,i)=>{t(i,e)&&this.delete(i)})}resolve(t){const{url:e}=f.fromUrl(t);return this.swup.resolveUrl(e)}}const A=(s,t=document)=>t.querySelector(s),M=(s,t=document)=>Array.from(t.querySelectorAll(s)),O=()=>new Promise(s=>{requestAnimationFrame(()=>{requestAnimationFrame(()=>{s()})})});function D(s){return!!s&&(typeof s=="object"||typeof s=="function")&&typeof s.then=="function"}function B(s,t=[]){return new Promise((e,i)=>{const n=s(...t);D(n)?n.then(e,i):e(n)})}const H=s=>window.CSS&&window.CSS.escape?CSS.escape(s):s,q=s=>1e3*Number(s.slice(0,-1).replace(",","."));class F{constructor(t){this.swup=void 0,this.swupClasses=["to-","is-changing","is-rendering","is-popstate","is-animating"],this.swup=t}get selectors(){const{scope:t}=this.swup.visit.animation;return t==="containers"?this.swup.visit.containers:t==="html"?["html"]:Array.isArray(t)?t:[]}get selector(){return this.selectors.join(",")}get targets(){return this.selector.trim()?M(this.selector):[]}add(...t){this.targets.forEach(e=>e.classList.add(...t))}remove(...t){this.targets.forEach(e=>e.classList.remove(...t))}clear(){this.targets.forEach(t=>{const e=t.className.split(" ").filter(i=>this.isSwupClass(i));t.classList.remove(...e)})}isSwupClass(t){return this.swupClasses.some(e=>t.startsWith(e))}}function z({to:s,from:t=this.currentPageUrl,hash:e,animate:i=!0,animation:n,el:o,event:a,action:r="push",resetScroll:l=!0}){return{from:{url:t},to:{url:s,hash:e},containers:this.options.containers,animation:{animate:i,wait:!1,name:n,scope:this.options.animationScope,selector:this.options.animationSelector},trigger:{el:o,event:a},history:{action:r,popstate:!1,direction:void 0},scroll:{reset:l,target:void 0}}}class K{constructor(t){this.swup=void 0,this.registry=new Map,this.hooks=["animation:out:start","animation:out:await","animation:out:end","animation:in:start","animation:in:await","animation:in:end","animation:skip","cache:clear","cache:set","content:replace","content:scroll","enable","disable","fetch:request","fetch:error","history:popstate","link:click","link:self","link:anchor","link:newtab","page:load","page:view","scroll:top","scroll:anchor","visit:start","visit:end"],this.swup=t,this.init()}init(){this.hooks.forEach(t=>this.create(t))}create(t){this.registry.has(t)||this.registry.set(t,new Map)}exists(t){return this.registry.has(t)}get(t){const e=this.registry.get(t);if(e)return e;console.error(`Unknown hook '${t}'`)}clear(){this.registry.forEach(t=>t.clear())}on(t,e,i={}){const n=this.get(t);if(!n)return console.warn(`Hook '${t}' not found.`),()=>{};const o=c({},i,{id:n.size+1,hook:t,handler:e});return n.set(e,o),()=>this.off(t,e)}before(t,e,i={}){return this.on(t,e,c({},i,{before:!0}))}replace(t,e,i={}){return this.on(t,e,c({},i,{replace:!0}))}once(t,e,i={}){return this.on(t,e,c({},i,{once:!0}))}off(t,e){const i=this.get(t);i&&e?i.delete(e)||console.warn(`Handler for hook '${t}' not found.`):i&&i.clear()}async call(t,e,i){const{before:n,handler:o,after:a}=this.getHandlers(t,i);await this.run(n,e);const[r]=await this.run(o,e);return await this.run(a,e),this.dispatchDomEvent(t,e),r}callSync(t,e,i){const{before:n,handler:o,after:a}=this.getHandlers(t,i);this.runSync(n,e);const[r]=this.runSync(o,e);return this.runSync(a,e),this.dispatchDomEvent(t,e),r}async run(t,e){const i=[];for(const{hook:n,handler:o,defaultHandler:a,once:r}of t){const l=await B(o,[this.swup.visit,e,a]);i.push(l),r&&this.off(n,o)}return i}runSync(t,e){const i=[];for(const{hook:n,handler:o,defaultHandler:a,once:r}of t){const l=o(this.swup.visit,e,a);i.push(l),D(l)&&console.warn(`Promise returned from handler for synchronous hook '${n}'.Swup will not wait for it to resolve.`),r&&this.off(n,o)}return i}getHandlers(t,e){const i=this.get(t);if(!i)return{found:!1,before:[],handler:[],after:[],replaced:!1};const n=this.sortRegistrations,o=Array.from(i.values()),a=o.filter(({before:h,replace:d})=>h&&!d).sort(n),r=o.filter(({replace:h})=>h).sort(n),l=o.filter(({before:h,replace:d})=>!h&&!d).sort(n),u=r.length>0;let p=[];if(e&&(p=[{id:0,hook:t,handler:e}],u)){const h=r.length-1,d=m=>{const g=r[m-1];return g?(w,y)=>g.handler(w,y,d(m-1)):e};p=[{id:0,hook:t,handler:r[h].handler,defaultHandler:d(h)}]}return{found:!0,before:a,handler:p,after:l,replaced:u}}sortRegistrations(t,e){var i,n;return((i=t.priority)!=null?i:0)-((n=e.priority)!=null?n:0)||t.id-e.id||0}dispatchDomEvent(t,e){document.dispatchEvent(new CustomEvent(`swup:${t}`,{detail:{hook:t,args:e,visit:this.swup.visit}}))}}const J=s=>{if(s&&s.charAt(0)==="#"&&(s=s.substring(1)),!s)return null;const t=decodeURIComponent(s);let e=document.getElementById(s)||document.getElementById(t)||A(`a[name='${H(s)}']`)||A(`a[name='${H(t)}']`);return e||s!=="top"||(e=document.body),e},k="transition",b="animation";async function X({elements:s,selector:t}){if(t===!1&&!s)return;let e=[];if(s)e=Array.from(s);else if(t&&(e=M(t,document.body),!e.length))return void console.warn(`[swup] No elements found matching animationSelector \`${t}\``);const i=e.map(n=>function(o){const{type:a,timeout:r,propCount:l}=function(u,p){const h=window.getComputedStyle(u),d=E(h,`${k}Delay`),m=E(h,`${k}Duration`),g=N(d,m),w=E(h,`${b}Delay`),y=E(h,`${b}Duration`),L=N(w,y);let S=null,U=0,x=0;return U=Math.max(g,L),S=U>0?g>L?k:b:null,x=S?S===k?m.length:y.length:0,{type:S,timeout:U,propCount:x}}(o);return!(!a||!r)&&new Promise(u=>{const p=`${a}end`,h=performance.now();let d=0;const m=()=>{o.removeEventListener(p,g),u()},g=w=>{if(w.target===o){if(!function(y){return[`${k}end`,`${b}end`].includes(y.type)}(w))throw new Error("Not a transition or animation event.");(performance.now()-h)/1e3<w.elapsedTime||++d>=l&&m()}};setTimeout(()=>{d<l&&m()},r+1),o.addEventListener(p,g)})}(n));i.filter(Boolean).length>0?await Promise.all(i):t&&console.warn(`[swup] No CSS animation duration defined on elements matching \`${t}\``)}function E(s,t){return(s[t]||"").split(", ")}function N(s,t){for(;s.length<t.length;)s=s.concat(s);return Math.max(...t.map((e,i)=>q(e)+q(s[i])))}function G(s,t={},e={}){if(typeof s!="string")throw new Error("swup.navigate() requires a URL parameter");if(this.shouldIgnoreVisit(s,{el:e.el,event:e.event}))return void(window.location.href=s);const{url:i,hash:n}=f.fromUrl(s);this.visit=this.createVisit(c({},e,{to:i,hash:n})),this.performNavigation(t)}async function Q(s={}){const{el:t}=this.visit.trigger;s.referrer=s.referrer||this.currentPageUrl,s.animate===!1&&(this.visit.animation.animate=!1),this.visit.animation.animate||this.classes.clear();const e=s.history||t?.getAttribute("data-swup-history")||void 0;e&&["push","replace"].includes(e)&&(this.visit.history.action=e);const i=s.animation||t?.getAttribute("data-swup-animation")||void 0;i&&(this.visit.animation.name=i);try{await this.hooks.call("visit:start");const n=this.hooks.call("page:load",{options:s},async(r,l)=>{const u=this.cache.get(r.to.url);return l.page=u||await this.fetchPage(r.to.url,l.options),l.cache=!!u,l.page});if(!this.visit.history.popstate){const r=this.visit.to.url+this.visit.to.hash;this.visit.history.action==="replace"||this.visit.to.url===this.currentPageUrl?P(r):W(r,{index:this.currentHistoryIndex+1})}if(this.currentPageUrl=v(),this.visit.animation.wait){const{html:r}=await n;this.visit.to.html=r}const o=this.animatePageOut(),[a]=await Promise.all([n,o]);await this.renderPage(this.visit.to.url,a),await this.animatePageIn(),await this.hooks.call("visit:end",void 0,()=>this.classes.clear())}catch(n){if(!n)return;console.error(n),this.options.skipPopStateHandling=()=>(window.location.href=this.visit.to.url+this.visit.to.hash,!0),window.history.go(-1)}}class R extends Error{constructor(t,e){super(t),this.url=void 0,this.status=void 0,this.name="FetchError",this.url=e.url,this.status=e.status}}async function Y(s,t={}){s=f.fromUrl(s).url;const e=c({},this.options.requestHeaders,t.headers);t=c({},t,{headers:e});const i=await this.hooks.call("fetch:request",{url:s,options:t},(u,{url:p,options:h})=>fetch(p,h)),{status:n,url:o}=i,a=await i.text();if(n===500)throw this.hooks.call("fetch:error",{status:n,response:i,url:o}),new R(`Server error: ${o}`,{status:n,url:o});if(!a)throw new R(`Empty response: ${o}`,{status:n,url:o});const{url:r}=f.fromUrl(o),l={url:r,html:a};return s===r&&this.cache.set(l.url,l),l}const Z=async function(){this.visit.animation.animate?(await this.hooks.call("animation:out:start",void 0,s=>{this.classes.add("is-changing","is-leaving","is-animating"),s.history.popstate&&this.classes.add("is-popstate"),s.animation.name&&this.classes.add(`to-${T(s.animation.name)}`)}),await this.hooks.call("animation:out:await",{skip:!1},async(s,{skip:t})=>{t||await this.awaitAnimations({selector:s.animation.selector})}),await this.hooks.call("animation:out:end")):await this.hooks.call("animation:skip")},tt=function({html:s},{containers:t}=this.options){var e;const i=new DOMParser().parseFromString(s,"text/html"),n=((e=i.querySelector("title"))==null?void 0:e.innerText)||"";return document.title=n,t.map(o=>{const a=document.querySelector(o),r=i.querySelector(o);return a&&r?(a.replaceWith(r),!0):(a||console.warn(`[swup] Container missing in current document: ${o}`),r||console.warn(`[swup] Container missing in incoming document: ${o}`),!1)}).filter(Boolean).length===t.length},et=function(){const s={behavior:"auto"},{target:t,reset:e}=this.visit.scroll,i=t||this.visit.to.hash;let n=!1;return i&&(n=this.hooks.callSync("scroll:anchor",{hash:i,options:s},(o,{hash:a,options:r})=>{const l=this.getAnchorElement(a);return l&&l.scrollIntoView(r),!!l})),e&&!n&&(n=this.hooks.callSync("scroll:top",{options:s},(o,{options:a})=>(window.scrollTo(c({top:0,left:0},a)),!0))),n},st=async function(){if(!this.visit.animation.animate)return;const s=this.hooks.call("animation:in:await",{skip:!1},async(t,{skip:e})=>{e||await this.awaitAnimations({selector:t.animation.selector})});await O(),await this.hooks.call("animation:in:start",void 0,()=>{this.classes.remove("is-animating")}),await s,await this.hooks.call("animation:in:end")},it=async function(s,t){const{url:e,html:i}=t;this.classes.remove("is-leaving"),this.isSameResolvedUrl(v(),s)&&(this.isSameResolvedUrl(v(),e)||(P(e),this.currentPageUrl=v(),this.visit.to.url=this.currentPageUrl),this.visit.animation.animate&&this.classes.add("is-rendering"),this.visit.to.html=i,await this.hooks.call("content:replace",{page:t},(n,{page:o})=>{if(!this.replaceContent(o,{containers:n.containers}))throw new Error("[swup] Container mismatch, aborting");n.animation.animate&&(this.classes.add("is-animating","is-changing","is-rendering"),n.animation.name&&this.classes.add(`to-${T(n.animation.name)}`))}),await this.hooks.call("content:scroll",void 0,()=>this.scrollToContent()),await this.hooks.call("page:view",{url:this.currentPageUrl,title:document.title}),this.options.cache||this.cache.clear())},nt=function(s){var t;if((t=s)!=null&&t.isSwupPlugin){if(s.swup=this,!s._checkRequirements||s._checkRequirements())return s._beforeMount&&s._beforeMount(),s.mount(),this.plugins.push(s),this.plugins}else console.error("Not a swup plugin instance",s)};function ot(s){const t=this.findPlugin(s);if(t)return t.unmount(),t._afterUnmount&&t._afterUnmount(),this.plugins=this.plugins.filter(e=>e!==t),this.plugins;console.error("No such plugin",t)}function rt(s){return this.plugins.find(t=>t===s||t.name===s||t.name===`Swup${s}`)}function at(s){if(typeof this.options.resolveUrl!="function")return console.warn("[swup] options.resolveUrl expects a callback function."),s;const t=this.options.resolveUrl(s);return t&&typeof t=="string"?t.startsWith("//")||t.startsWith("http")?(console.warn("[swup] options.resolveUrl needs to return a relative url"),s):t:(console.warn("[swup] options.resolveUrl needs to return a url"),s)}function lt(s,t){return this.resolveUrl(s)===this.resolveUrl(t)}const ht={animateHistoryBrowsing:!1,animationSelector:'[class*="transition-"]',animationScope:"html",cache:!0,containers:["#swup"],ignoreVisit:(s,{el:t}={})=>!(t==null||!t.closest("[data-no-swup]")),linkSelector:"a[href]",linkToSelf:"scroll",plugins:[],resolveUrl:s=>s,requestHeaders:{"X-Requested-With":"swup",Accept:"text/html, application/xhtml+xml"},skipPopStateHandling:s=>{var t;return((t=s.state)==null?void 0:t.source)!=="swup"}};class ct{constructor(t={}){this.version="4.2.0",this.options=void 0,this.defaults=ht,this.plugins=[],this.visit=void 0,this.cache=void 0,this.hooks=void 0,this.classes=void 0,this.currentPageUrl=v(),this.currentHistoryIndex=1,this.clickDelegate=void 0,this.use=nt,this.unuse=ot,this.findPlugin=rt,this.log=()=>{},this.navigate=G,this.performNavigation=Q,this.createVisit=z,this.delegateEvent=_,this.fetchPage=Y,this.awaitAnimations=X,this.renderPage=it,this.replaceContent=tt,this.animatePageIn=st,this.animatePageOut=Z,this.scrollToContent=et,this.getAnchorElement=J,this.getCurrentUrl=v,this.resolveUrl=at,this.isSameResolvedUrl=lt,this.options=c({},this.defaults,t),this.handleLinkClick=this.handleLinkClick.bind(this),this.handlePopState=this.handlePopState.bind(this),this.cache=new j(this),this.classes=new F(this),this.hooks=new K(this),this.visit=this.createVisit({to:""}),this.checkRequirements()&&this.enable()}checkRequirements(){return typeof Promise<"u"||(console.warn("Promise is not supported"),!1)}async enable(){const{linkSelector:t}=this.options;this.clickDelegate=this.delegateEvent(t,"click",this.handleLinkClick),window.addEventListener("popstate",this.handlePopState),this.options.plugins.forEach(e=>this.use(e)),P(null,{index:1}),await O(),await this.hooks.call("enable",void 0,()=>{document.documentElement.classList.add("swup-enabled")})}async destroy(){this.clickDelegate.destroy(),window.removeEventListener("popstate",this.handlePopState),this.cache.clear(),this.options.plugins.forEach(t=>this.unuse(t)),await this.hooks.call("disable",void 0,()=>{document.documentElement.classList.remove("swup-enabled")}),this.hooks.clear()}shouldIgnoreVisit(t,{el:e,event:i}={}){const{origin:n,url:o,hash:a}=f.fromUrl(t);return n!==window.location.origin||!(!e||!this.triggerWillOpenNewWindow(e))||!!this.options.ignoreVisit(o+a,{el:e,event:i})}handleLinkClick(t){const e=t.delegateTarget,{href:i,url:n,hash:o}=f.fromElement(e);this.shouldIgnoreVisit(i,{el:e,event:t})||(this.visit=this.createVisit({to:n,hash:o,el:e,event:t}),t.metaKey||t.ctrlKey||t.shiftKey||t.altKey?this.hooks.call("link:newtab",{href:i}):t.button===0&&this.hooks.callSync("link:click",{el:e,event:t},()=>{var a;const r=(a=this.visit.from.url)!=null?a:"";t.preventDefault(),n&&n!==r?this.isSameResolvedUrl(n,r)||this.performNavigation():o?this.hooks.callSync("link:anchor",{hash:o},()=>{P(n+o),this.scrollToContent()}):this.hooks.callSync("link:self",void 0,()=>this.options.linkToSelf==="navigate"?this.performNavigation():this.scrollToContent())}))}handlePopState(t){var e,i,n;const o=(e=(i=t.state)==null?void 0:i.url)!=null?e:location.href;if(this.options.skipPopStateHandling(t)||this.isSameResolvedUrl(v(),this.currentPageUrl))return;const{url:a,hash:r}=f.fromUrl(o);this.visit=this.createVisit({to:a,hash:r,event:t,animate:this.options.animateHistoryBrowsing,resetScroll:this.options.animateHistoryBrowsing}),this.visit.history.popstate=!0;const l=Number((n=t.state)==null?void 0:n.index);l&&(this.visit.history.direction=l-this.currentHistoryIndex>0?"forwards":"backwards"),this.hooks.callSync("history:popstate",{event:t},()=>{this.performNavigation()})}triggerWillOpenNewWindow(t){return!!t.matches('[download], [target="_blank"]')}}const ut=Object.freeze(Object.defineProperty({__proto__:null,default:ct},Symbol.toStringTag,{value:"Module"}));export{ut as S,f as l,v as n,M as p};
